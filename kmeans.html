<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> 
	
	
	<!-- d3 code -->
	<script src="https://d3js.org/d3.v5.min.js"></script>
	<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
	<script src="http://dbslice.org/d3-tip.js"></script>

	
	
	<!-- NEW gl-matrix, twgl -->
	<script src="/src/outside/gl-matrix-min.js"></script>
	<script src="/src/outside/twgl.min.js"></script>
	
	
	<!-- Add icon library -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	
	<!-- Custom CSS -->
	<link rel="stylesheet" href="/src/style/canvas.css">
	
	
</head>
  
  
<body>

  <div id="plotWrapper">
    
	<div>
		<button class="btn" id="tsne">t-sne</button>
		<button class="btn" id="kmeans">k-means</button>
		<button class="btn" id="step">k-step</button>
		<button class="btn" id="clear">clear</button>
	</div>
	
	<svg id="plot" width="300" height="300" style="border: solid 4px black;"></svg>

  </div>
  
	
  
  

  
  
  <script type="module">
  
    import { dbsliceData } from "/src/core/dbsliceData.js"
	import { contour2dFile } from "/src/core/fileClasses.js"
	import {cfD3Contour2d} from "/src/plot/cfD3Contour2d.js"
	
	import * as tsnejs from "/src/outside/tsne_module.js"
	import * as clustering from "/src/core/kmeans_dev.js"
  
  // PROJECTION IS DEFINED BY THE CANVAS SIZE!!
  
  
	var data = {
		points: [],
		domain: {
		  x: undefined,
		  y: undefined,
		  c: d3.scaleOrdinal(d3.schemeCategory10)
		},
		kmeans: undefined,
	}
  
  
  

    var nacaDesignations = ['0006', '0008', '0010', '0015', '0018', '0021', '0024', '1408', '1410', '1412', '23012', '23015', '23018', '23021', '23024', '2408', '2410', '2411', '2412', '2415', '2418', '2421', '2424', '4412', '4415', '4418', '4421', '4424', '6412'] // nacaDesignations  
  
    var requested = nacaDesignations.map(function(designation){
		return {
			taskId: designation,
			url: "/data/xfoil2d/vels_repanelled_naca_" + designation + ".json",
			filename: "/data/xfoil2d/vels_repanelled_naca_" + designation + ".json"
		}
	})
	

	let promises = dbsliceData.importing.batch( contour2dFile, requested)
	
	
	
	// Launch a task upon loading completion.
	Promise.allSettled( promises ).then(function(promiseobjs){
		
		// Pipe the results back into the contour.
		let fileobjs = promiseobjs
		  .filter(function(promiseobj){
			return promiseobj.value.content != undefined 
		  })
		  .map(d=>d.value)
		
		
		// Make internal data.
		data.points = fileobjs.map(function(fileobj){
			return {
				taskId: fileobj.filename,
				cp: fileobj.content[0].data.Cp,
				pos: undefined,
				groupid: 0
			}
		}) // map
		
		
		// Make the k-means object.
		data.kmeans = new clustering.kmeans(data.points)
		
		
		// Position the points
		position()

		
		
		// Draw the points.
		draw()
		
		// Add group adding functionality.
		let svg = d3.select("#plot")
		  .on("click", function(){
		    let pos = d3.mouse(this)
		    data.kmeans.addgroup(pos)
			
			draw()
			
		  })
		
	}) // then
	
	
	
	// Add functionality to the buttons.
	d3.select( document.getElementById("tsne") ).on("click", function(){
		position()
		draw()
	}) // on
	
	d3.select( document.getElementById("kmeans") ).on("click", function(){
		data.kmeans.cluster()
		draw()
	}) // on
	
	d3.select( document.getElementById("step") ).on("click", function(){
		data.kmeans.step()
		draw()
	}) // on
	
	d3.select( document.getElementById("clear") ).on("click", function(){
		data.kmeans.clear()
		data.points.forEach(function(point){
			point.groupid = 0
		})
		draw()
	}) // on
	
	
	
	function position(){
	
		let Y = tsne(data.points.map(d=>d.cp))
		
		
		let xdom = d3.extent(Y, d=>d[0])
		let ydom = d3.extent(Y, d=>d[1])
		
		data.domain.x = d3.scaleLinear()
		  .domain( [xdom[0] - 0.1*(xdom[1]-xdom[0]), xdom[1] + 0.1*(xdom[1]-xdom[0])] )
		  .range([0,300])
		  
		data.domain.y = d3.scaleLinear()
		  .domain( [ydom[0] - 0.1*(ydom[1]-ydom[0]), ydom[1] + 0.1*(ydom[1]-ydom[0])] )
		  .range([0,300])
		  
		data.points.forEach(function(point, i){
			point.pos = [data.domain.x( Y[i][0] ),
			             data.domain.y( Y[i][1] )]
		})
	
	} // restart 
	
	
	function draw(){
		let svg = d3.select("#plot")
	
		let c = data.domain.c
	
		// Points
		svg.selectAll("circle")
		  .data( data.points, d=>d.taskId )
		  .join(
			enter => enter.append("circle")
			  .attr("cx", d=>d.pos[0])
			  .attr("cy", d=>d.pos[1])
			  .attr("fill",d=>c(d.groupid))
			  .attr("r", 4),
			update => update
			  .attr("cx", d=>d.pos[0])
			  .attr("cy", d=>d.pos[1])
			  .attr("fill",d=>c(d.groupid)),
			exit => exit.remove()
		  ) // join
		  
		// Group centers.
		svg.selectAll("rect")
		  .data( data.kmeans.groups, d=>d.id )
		  .join(
		    enter => enter.append("rect")
			  .attr("x", d=>d.pos[0])
			  .attr("y", d=>d.pos[1])
			  .attr("width", 4)
			  .attr("height", 4)
			  .style("fill", d=>c(d.id)),
			update => update
			  .attr("x", d=>d.pos[0])
			  .attr("y", d=>d.pos[1])
			  .style("fill", d=>c(d.id)),
			exit => exit.remove()
		  ) // join
		  
		d3.select("#plot")
			  
		  
	} // draw
	
	function tsne(cp){
	
		// The options MUST be configured correctly for t-sne to produce meaningful results!!
		// perplexity must be smaller than the number of actual cases, maybe a third or so?
		var opt = {}
		opt.epsilon = 10; // epsilon is learning rate (10 = default)
		opt.perplexity = Math.round( cp.length / 5 ); // roughly how many neighbors each point influences (30 = default)
		opt.dim = 2; // dimensionality of the embedding (2 = default)

		var tsne = new tsnejs.tSNE(opt); // create a tSNE instance

		// initialize the raw data.
		tsne.initDataRaw(cp);

		for(var k = 0; k < 5000; k++) {
		  tsne.step(); // every time you call this, solution gets better
		} // for

		var Y = tsne.getSolution(); // Y is an array of 2-D points that you can plot
		
		return Y
	} // tsne
	
	
	
	
	
  </script>
  
  
</body>
</html>
